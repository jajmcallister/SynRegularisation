using Plots
using Random, Distributions
using LinearAlgebra
using LaTeXStrings
import Statistics
using StatsPlots

# random.seed!(1234)

function create_correlation_matrix(n)
    m = [zeros(n) for i=1:n]
    for i in 1:n
        for j in 1:n
            if i <= n/2 && j <= n/2
                m[i][j]=0.5
                m[j][i]=0.5
            elseif i > n/2 && j >n/2
                m[i][j]=0.5
                m[j][i]=0.5
            end
            if i <= n/6 && j<=n/6
                m[i][j]=0.8
                m[j][i]=0.8
            elseif i > n/6 && i <= n/3 && j > n/6 && j<= n/3
                m[i][j]=0.8
                m[j][i]=0.8
            elseif i > n/3 && i <= n/2 && j > n/3 && j <= n/2
                m[i][j]=0.8
                m[j][i]=0.8
            elseif i > n/2 && i <= 2/3*n && j > n/2 && j <=2/3*n
                m[i][j]=0.8
                m[j][i]=0.8
            elseif i > 2/3*n && i <= 5/6*n && j > 2/3*n && j <= 5/6*n
                m[i][j]=0.8
                m[j][i]=0.8
            elseif i > 5/6*n && i<=n && j > 5/6*n && i<=n
                m[i][j]=0.8
                m[j][i]=0.8
            end
        end
    end
    k = hcat(m...)
    k[diagind(k)] .= 1
    return k
end

n_synapses = 60
n_trials = 10

x_axis = 1:n_trials
weights = [ones(n_synapses) for i=1:n_trials+1]
eta = 1
dw = [[] for i=1:n_trials]
outputs = Float64[]
baseline_outputs = Float64[]


# creating samples from multivariate  gaussian
mu = ones(n_synapses)
stdx = 0.3
corr = create_correlation_matrix(n_synapses)
cov = corr * stdx^2

d = MvNormal(mu,cov)

heatmap(cov, yflip=true)

trials = rand(d, n_trials)'

# this is a function that converts the matrix into array (for indexing)
function slicematrix(A::AbstractMatrix{T}) where T
    m, n = size(A)
    B = Vector{T}[Vector{T}(undef, n) for _ in 1:m]
    for i in 1:m
        B[i] .= A[i, :]
    end
    return B
end

new_trials = slicematrix(trials)


for i in 1:n_trials
    output=sum(new_trials[i].*weights[i])/n_synapses
    baseline_output=sum(new_trials[i])/n_synapses
    append!(outputs, output)
    append!(baseline_outputs, baseline_output)
    for j in 1:n_synapses 
        delta_w = eta*new_trials[i][j]*outputs[i]
        append!(dw[i], delta_w)
    end
end


# Generating plots of input, output, and weight changes only for the first 5 synapses
P1 = plot()
for l in 1:5
    local n= (getindex.(new_trials, l))
    plot!(P1, n, marker=(:circle,7), markerstrokewidth=0, grid=true, ylabel="Presynaptic Output", linewidth=2)
end


P2 = plot(outputs, color="grey", ylim=(0,maximum(outputs)+0.2), marker=(:circle,7), markerstrokewidth=0, legend=false, ylabel="Postsynaptic Output", 
linewidth=2)

P3 = plot()
for l in 1:5
    m= (getindex.(dw, l))
    plot!(P3, m, marker=(:circle,7), markerstrokewidth=0, ylabel=L"$\Delta$w", linewidth=2)
end

P = plot(P1, P2, P3, layout=(3,1), xticks=x_axis, fmt = :png)
plot!(size=(900,900))


# ############################################
# ############################################

# This transpose is to calculate correlations of the synapses across samples, not vice versa
samples = new_trials'
dws = dw'

# Correlation matrices
M1 = Plots.heatmap(corr, yflip=true, title="Input Correlations", xlabel="Synapse number", ylabel="Synapse number")

# N = cor(vcat(dws...))
N1 = Plots.heatmap(N, yflip=true, title=L"$\Delta$w Correlations", xlabel="Synapse number", ylabel="Synapse number")

plot(M1, N1, layout=(1,2))
plot!(size=(900, 400))



############################################
############################################

mean_baseline = mean(baseline_outputs)
var_baseline = var(baseline_outputs)
mean_output = mean(outputs)
variance_output = var(outputs)
input_trials = slicematrix(trials')
vars = Float64[]
means = Float64[]
covars_dwi_dwj = [zeros(n_synapses) for i in 1:n_synapses]


for i in 1:n_trials
    yy = 0
    for j in 1:n_synapses
        yy += dws[i][j]
    end
    zz = yy + outputs[i]
    append!(means,zz)
end    



# #working out cov(dwi,dwj)
function cov_dwi_dwj(i,j, input, output)
    covv = eta^2 * (mu[i]*mu[j]*var(outputs) + mu[i]*mean(output)*Statistics.cov(input[i], output) + mu[j]*mean(output)*Statistics.cov(input[i],output)+ (mean(output))^2 * Statistics.cov(input[i],input[j]) + Statistics.cov(input[i], input[j])*var(output)+Statistics.cov(input[i], outputs)*Statistics.cov(input[j],output))
    return covv
end

for i in 1:n_synapses
    for j in 1:n_synapses
        local xx = cov_dwi_dwj(i, j, input_trials, outputs)
        covars_dwi_dwj[i][j] = xx
        covars_dwi_dwj[j][i] = xx
    end
end

heatmap(hcat(covars_dwi_dwj...), yflip=true, title=L"Cov($\Delta w_i$, $\Delta w_j$)")
plot!(size=(600, 600))

for i in 1:n_trials
    zz = (sqrt(((outputs[i])/mean_baseline-(mean_output)/mean_baseline)^2))+variance_output
    append!(vars, zz)
end



# vareyw = sum(sum(covars_dwi_dwj))



plot(x->pdf(Normal(mean_baseline/mean_baseline, var_baseline), x), color="grey", linewidth=4, yformatter=_->"", yticks=false, xlabel="Postsynaptic Output", legend=false)
plot!(x->pdf(Normal((mean_output+mean_output*mean(mean(dws)))/mean_baseline+2, variance_output), x), color="blue", linewidth=4)
for i in 1:n_trials
    plot!(x->pdf(Normal((outputs[i] + mean(dws[i])*mean_output)/mean_baseline+2, vars[i]), x), color="green", linewidth=1, xlim=(0,5))
end
current()
